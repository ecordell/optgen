package main

import (
	"errors"
	"flag"
	"fmt"
	"go/ast"
	"go/importer"
	"go/parser"
	"go/token"
	"go/types"
	"io"
	"log"
	"os"
	"strings"

	"github.com/dave/jennifer/jen"
)

func main() {
	cwd, err := os.Getwd()
	if err != nil {
		log.Fatal(" couldn't determine current working directory")
	}

	fs := flag.NewFlagSet("optgen", flag.ContinueOnError)
	//outputPathFlag := fs.String(
	//	"o",
	//	"",
	//	"Location where generated options will be written",
	//)

	if err := fs.Parse(os.Args[1:]); err != nil {
		log.Fatal(err.Error())
	}

	if len(fs.Args()) == 0 {
		// TODO: usage
		log.Fatal("must specify a struct to provide options for")
	}

	structName := fs.Arg(0)

	err = func() error {
		fset := token.NewFileSet()
		var f map[string]*ast.Package
		f, err = parser.ParseDir(fset, cwd, nil, 0)
		if err != nil {
			return err
		}

		var files []*ast.File
		for i := range f {
			for j := range f[i].Files {
				files = append(files, f[i].Files[j])
			}
			for j := range f[i].Files {
				if !strings.Contains(j, "_opts.go") {
					err = generate(fset, f[i].Files[j], files, cwd, i, j, structName, nil)
					if err != nil {
						return err
					}
				}
			}
		}
		return nil
	}()
	if err != nil {
		log.Fatal(err)
	}
}

func generate(set *token.FileSet, current *ast.File, all []*ast.File, dirname string, pkgName string, fileName string, structName string, writer io.Writer) error {
	found := make([]*ast.TypeSpec, 0)
	ast.Inspect(current, func(node ast.Node) bool {
		var ts *ast.TypeSpec
		var ok bool

		if ts, ok = node.(*ast.TypeSpec); !ok {
			return true
		}

		if ts.Name == nil {
			return true
		}

		if !strings.Contains(ts.Name.Name, structName) {
			return false
		}

		found = append(found, ts)

		return false
	})

	if len(found) == 0 {
		return nil
	}


	defs := make(map[*ast.Ident]types.Object)
	infos := &types.Info{Defs: defs}
	config := types.Config{Importer: importer.ForCompiler(set, "source", nil), FakeImportC: true}
	pkg, err := config.Check(dirname, set, all, infos)
	if err != nil {
		return err
	}

	buf := jen.NewFilePathName(pkg.Path(), pkgName)
	buf.PackageComment("Code generated by github.com/ecordell/optgen. DO NOT EDIT.")

	for _, s := range found {
		switch s.Type.(type) {
		case *ast.StructType:
			def, ok := defs[s.Name]
			if !ok {
				continue
			}
			st, ok := def.Type().Underlying().(*types.Struct)
			if !ok {
				return errors.New("type is not a struct")
			}

			receiverId := string(def.Name()[0])
			optTypeName := fmt.Sprintf("%sOption", def.Name())

			// generate the Option type
			buf.Type().Id(optTypeName).Func().Params(jen.Id(receiverId).Op("*").Id(def.Name()))

			// generate NewXWithOptions
			buf.Func().Id(fmt.Sprintf("New%sWithOptions", strings.Title(def.Name()))).Params(
				jen.Id("opts").Op("...").Id(optTypeName),
			).Op("*").Id(def.Name()).BlockFunc(func(grp *jen.Group) {
				grp.Id(receiverId).Op(":=").Op("&").Id(def.Name()).Block()
				grp.For(jen.Id("_").Op(",").Id("o").Op(":=").Op("range").Id("opts")).Block(
					jen.Id("o").Params(jen.Id(receiverId)),
				)

				grp.Return(
					jen.Id(receiverId),
				)
			})

			// generate WithOptions
			buf.Func().Id(fmt.Sprintf("%sWithOptions", def.Name())).Params(
				jen.Id(receiverId).Op("*").Id(def.Name()), jen.Id("opts").Op("...").Id(optTypeName),
			).Op("*").Id(def.Name()).BlockFunc(func(grp *jen.Group) {
				grp.For(jen.Id("_").Op(",").Id("o").Op(":=").Op("range").Id("opts")).Block(
					jen.Id("o").Params(jen.Id(receiverId)),
				)

				grp.Return(
					jen.Id(receiverId),
				)
			})

			// generate all With* functions
			for i := 0; i < st.NumFields(); i++ {
				f := st.Field(i)
				if f.Anonymous() {
					continue
				}

				buf.Func().Id(fmt.Sprintf("With%s", strings.Title(f.Name()))).Params(
					jen.Id(f.Name()).Id(f.Type().String()),
				).Id(optTypeName).BlockFunc(func(grp *jen.Group) {
					grp.Return(
						jen.Func().Params(jen.Id(receiverId).Op("*").Id(def.Name())).BlockFunc(func(grp2 *jen.Group) {
							grp2.Id(receiverId).Op(".").Id(f.Name()).Op("=").Id(f.Name())
						}),
					)
				})
			}
		default:
		}
	}

	optFile := strings.Replace(fileName, ".go", "_opts.go", 1)
	writer, err = os.OpenFile(optFile, os.O_CREATE|os.O_RDWR, 0600)
	if err != nil {
		return err
	}

	return buf.Render(writer)
}
