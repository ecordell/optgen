package main

import (
	"errors"
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"go/types"
	"io"
	"log"
	"os"
	"path"
	"path/filepath"
	"strings"
	"unicode"

	"github.com/dave/jennifer/jen"
	"golang.org/x/tools/go/packages"
)

type WriterProvider func() io.Writer

// TODO: struct tags to know what to generate
// TODO: recursive generation WithMetadata(WithName())
// TODO: optional flattening of recursive generation WithMetadataName()
// TODO: field prefix
// TODO: exported / unexported generation
// TODO: set/with for arrays and maps

func main() {
	fs := flag.NewFlagSet("optgen", flag.ContinueOnError)
	outputPathFlag := fs.String(
		"output",
		"",
		"Location where generated options will be written",
	)

	pkgNameFlag := fs.String(
		"package",
		"",
		"Name of package to use in output file",
	)

	if err := fs.Parse(os.Args[1:]); err != nil {
		log.Fatal(err.Error())
	}

	if len(fs.Args()) < 2  {
		// TODO: usage
		log.Fatal("must specify a package directory and a struct to provide options for")
	}

	pkgName := fs.Arg(0)
	structName := fs.Arg(1)
	//
	//if pkgName == "." {
	//	pkgName = cwd
	//}

	//pkgName = path.Clean(pkgName)

	var writer WriterProvider
	if outputPathFlag != nil {
		writer = func() io.Writer {
			w, err := os.OpenFile(*outputPathFlag, os.O_CREATE|os.O_RDWR|os.O_TRUNC, 0600)
			if err != nil {
				log.Fatalf("couldn't open %s for writing", *outputPathFlag)
			}
			return w
		}
	}

	packageName, err := func() (string, error) {
		if pkgNameFlag != nil && *pkgNameFlag != "" {
			return *pkgNameFlag, nil
		}
		fset := token.NewFileSet()
		var f map[string]*ast.Package
		f, err := parser.ParseDir(fset, path.Dir(*outputPathFlag), nil, 0)
		if err != nil {
			return "", err
		}
		for i := range f {
			for _, node := range f[i].Files {
				return node.Name.String(), nil
			}
		}
		return "", fmt.Errorf("no package name found")
	}()
	if err != nil {
		log.Fatalf("couldn't determine package for %s, consider providing explicitly", *outputPathFlag)
	}

	err = func() error {
		cfg := &packages.Config{
			Mode: packages.NeedFiles | packages.NeedTypes | packages.NeedTypesInfo | packages.NeedImports | packages.NeedSyntax,
		}
		pkgs, err := packages.Load(cfg, pkgName)
		if err != nil {
			fmt.Fprintf(os.Stderr, "load: %v\n", err)
			os.Exit(1)
		}
		if packages.PrintErrors(pkgs) > 0 {
			os.Exit(1)
		}

		for _, pkg := range pkgs {
			for _, f := range pkg.Syntax {
				err = generate(pkg.Fset, f, pkg, pkg.TypesInfo.Defs, pkg.ID, packageName, f.Name.Name, structName, *outputPathFlag, writer)
				if err != nil {
					return err
				}
			}
		}

		return nil
	}()
	if err != nil {
		log.Fatal(err)
	}
}

type v struct {
	info *types.Info
	file *ast.File
}

func (v *v) Visit(node ast.Node) ast.Visitor {
	switch node := node.(type) {
	case *ast.StructType:
		for _,f  := range node.Fields.List {
			fmt.Println("FIELD", f)
			fmt.Println("TYPE", f.Type)
			fmt.Println("POS", f.Pos())

			//path, _ := astutil.PathEnclosingInterval(v.file, f.Pos(), f.End())
			////v.info.Uses[path[0]]
			//v.info.TypeOf(path[0])
			//fmt.Println("PATH", path)
			//for _, n := range path {
			//	fmt.Printf("N %#v\n", n)
			//}
		}
		//fmt.Println("NODE", node.Fields)
		//fmt.Println(v.info.Uses[node])
	case *ast.CallExpr:
		// Get some kind of *ast.Ident for the CallExpr that represents the
		// package. Then we can look it up in v.info. Where exactly it sits in
		// the ast depends on the form of the function call.
		//fm
		switch node := node.Fun.(type) {
		case *ast.SelectorExpr: // foo.ReadFile
			pkgID := node.X.(*ast.Ident)
			fmt.Println(v.info.Uses[pkgID].(*types.PkgName).Imported().Path())

		case *ast.Ident:        // ReadFile
			pkgID := node
			fmt.Println(v.info.Uses[pkgID].Pkg().Path())
		}
	}

	return v
}

func generate(set *token.FileSet, current *ast.File, pkg *packages.Package, defs map[*ast.Ident]types.Object, dirname string, pkgName string, fileName string, structName string, outpath string, writer WriterProvider) error {
	found := make([]*ast.TypeSpec, 0)
	ast.Inspect(current, func(node ast.Node) bool {
		var ts *ast.TypeSpec
		var ok bool

		if ts, ok = node.(*ast.TypeSpec); !ok {
			return true
		}

		if ts.Name == nil {
			return true
		}

		if ts.Name.Name != structName {
			return false
		}
		found = append(found, ts)

		return false
	})

	if len(found) == 0 {
		return nil
	}

	outdir, err := filepath.Abs(filepath.Dir(outpath))
	if err != nil {
		return err
	}

	buf := jen.NewFilePathName(outpath, pkgName)
	buf.PackageComment("Code generated by github.com/ecordell/optgen. DO NOT EDIT.")

	for _, s := range found {
		switch s.Type.(type) {
		case *ast.StructType:
			def, ok := defs[s.Name]
			if !ok {
				continue
			}
			st, ok := def.Type().Underlying().(*types.Struct)
			if !ok {
				return errors.New("type is not a struct")
			}

			receiverId := strings.ToLower(string(def.Name()[0]))
			optTypeName := fmt.Sprintf("%sOption", def.Name())

			// if output to the same package, don't qualify imports
			structRef := func(s *jen.Statement) {
				s.Id(def.Name())
			}
			structName := def.Name()
			if outdir != st.Field(0).Pkg().Path() {
				structRef = func(s *jen.Statement) {
					s.Qual(st.Field(0).Pkg().Path(), def.Name())
				}
				structName = jen.Qual(st.Field(0).Pkg().Path(), def.Name()).GoString()
			}

			// generate the Option type
			buf.Type().Id(optTypeName).Func().Params(jen.Id(receiverId).Op("*").Do(structRef))

			// generate NewXWithOptions
			newFuncName := fmt.Sprintf("New%sWithOptions", strings.Title(def.Name()))
			buf.Comment(fmt.Sprintf("%s creates a new %s with the passed in options set", newFuncName, structName))
			buf.Func().Id(newFuncName).Params(
				jen.Id("opts").Op("...").Id(optTypeName),
			).Op("*").Do(structRef).BlockFunc(func(grp *jen.Group) {
				grp.Id(receiverId).Op(":=").Op("&").Do(structRef).Block()
				grp.For(jen.Id("_").Op(",").Id("o").Op(":=").Op("range").Id("opts")).Block(
					jen.Id("o").Params(jen.Id(receiverId)),
				)
				grp.Return(jen.Id(receiverId))
			})

			// generate WithOptions
			withFuncName := fmt.Sprintf("%sWithOptions", strings.Title(def.Name()))
			buf.Comment(fmt.Sprintf("%s configures an existing %s with the passed in options set", withFuncName, structName))
			buf.Func().Id(withFuncName).Params(
				jen.Id(receiverId).Op("*").Do(structRef), jen.Id("opts").Op("...").Id(optTypeName),
			).Op("*").Do(structRef).BlockFunc(func(grp *jen.Group) {
				grp.For(jen.Id("_").Op(",").Id("o").Op(":=").Op("range").Id("opts")).Block(
					jen.Id("o").Params(jen.Id(receiverId)),
				)
				grp.Return(jen.Id(receiverId))
			})

			// generate all With* functions
			for i := 0; i < st.NumFields(); i++ {
				f := st.Field(i)
				if f.Anonymous() {
					continue
				}

				if !f.Exported() && outdir != f.Pkg().Path() {
					continue
				}

				if outdir != st.Field(0).Pkg().Path() {
					structRef = func(s *jen.Statement) {
						s.Qual(st.Field(0).Pkg().Path(), def.Name())
					}
					structName = jen.Qual(st.Field(0).Pkg().Path(), def.Name()).GoString()
				}

				// build a type specifier based on the field type
				typeRef := []jen.Code{}
				current := f.Type()
				LOOP:
				for {
					switch t := current.(type) {
					case *types.Array:
						typeRef = append(typeRef, jen.Index())
						current = t.Elem()
					case *types.Slice:
						typeRef = append(typeRef, jen.Index())
						current = t.Elem()
					case *types.Pointer:
						typeRef = append(typeRef, jen.Op("*"))
						current = t.Elem()
					case *types.Named:
						// TODO: there must be a better way
						parts := strings.Split(t.String(),".")
						suffix := parts[len(parts)-1]
						typeRef = append(typeRef, jen.Qual(strings.Join(parts[:len(parts)-1], "."), suffix))
						break LOOP
					case *types.Basic:
						typeRef = append(typeRef, jen.Id(t.Name()))
						break LOOP
					case *types.Struct:
						typeRef = append(typeRef, jen.Struct())
						break LOOP
					}
				}

				unexport := func(s string) string {
					if len(s)==0 {
						return s
					}
					r := []rune(s)
					r[0] = unicode.ToLower(r[0])
					return string(r)
				}

				fieldFuncName := fmt.Sprintf("With%s", strings.Title(f.Name()))
				buf.Comment(fmt.Sprintf("%s returns an option that can set %s on a %s", fieldFuncName, strings.Title(f.Name()), structName))
				buf.Func().Id(fmt.Sprintf("With%s", strings.Title(f.Name()))).Params(
					jen.Id(unexport(f.Name())).Add(typeRef...),
				).Id(optTypeName).BlockFunc(func(grp *jen.Group) {
					grp.Return(
						jen.Func().Params(jen.Id(receiverId).Op("*").Do(structRef)).BlockFunc(func(grp2 *jen.Group) {
							grp2.Id(receiverId).Op(".").Id(f.Name()).Op("=").Id(f.Name())
						}),
					)
				})
			}
		default:
		}
	}

	w := writer()
	if w == nil {
		optFile := strings.Replace(fileName, ".go", "_opts.go", 1)
		w, err = os.OpenFile(optFile, os.O_CREATE|os.O_RDWR|os.O_TRUNC, 0600)
		if err != nil {
			return err
		}
	}

	return buf.Render(w)
}
