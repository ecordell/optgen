// Code generated by github.com/ecordell/optgen. DO NOT EDIT.
package testdata

import (
	"fmt"
	defaults "github.com/creasty/defaults"
)

type SlicesAndMapsOption func(s *SlicesAndMaps)

// NewSlicesAndMapsWithOptions creates a new SlicesAndMaps with the passed in options set
func NewSlicesAndMapsWithOptions(opts ...SlicesAndMapsOption) *SlicesAndMaps {
	s := &SlicesAndMaps{}
	for _, o := range opts {
		o(s)
	}
	return s
}

// NewSlicesAndMapsWithOptionsAndDefaults creates a new SlicesAndMaps with the passed in options set starting from the defaults
func NewSlicesAndMapsWithOptionsAndDefaults(opts ...SlicesAndMapsOption) *SlicesAndMaps {
	s := &SlicesAndMaps{}
	defaults.MustSet(s)
	for _, o := range opts {
		o(s)
	}
	return s
}

// ToOption returns a new SlicesAndMapsOption that sets the values from the passed in SlicesAndMaps
func (s *SlicesAndMaps) ToOption() SlicesAndMapsOption {
	return func(to *SlicesAndMaps) {
		to.Tags = s.Tags
		to.Metadata = s.Metadata
		to.Ports = s.Ports
	}
}

// DebugMap returns a map form of SlicesAndMaps for debugging
func (s *SlicesAndMaps) DebugMap() map[string]any {
	debugMap := map[string]any{}
	if s.Tags == nil {
		debugMap["Tags"] = "nil"
	} else {
		debugTags := make([]any, 0, len(s.Tags))
		for _, v := range s.Tags {
			if v == "" {
				debugTags = append(debugTags, "(empty)")
			} else {
				debugTags = append(debugTags, v)
			}
		}
		debugMap["Tags"] = debugTags
	}
	if s.Metadata == nil {
		debugMap["Metadata"] = "nil"
	} else {
		debugMap["Metadata"] = fmt.Sprintf("%v", s.Metadata)
	}
	if s.Ports == nil {
		debugMap["Ports"] = "nil"
	} else {
		debugPorts := make([]any, 0, len(s.Ports))
		for _, v := range s.Ports {
			debugPorts = append(debugPorts, v)
		}
		debugMap["Ports"] = debugPorts
	}
	return debugMap
}

// FlatDebugMap returns a flattened map form of SlicesAndMaps for debugging
// Nested maps are flattened using dot notation (e.g., "parent.child.field")
func (s *SlicesAndMaps) FlatDebugMap() map[string]any {
	return flattenDebugMap(s.DebugMap())
}

// SlicesAndMapsWithOptions configures an existing SlicesAndMaps with the passed in options set
func SlicesAndMapsWithOptions(s *SlicesAndMaps, opts ...SlicesAndMapsOption) *SlicesAndMaps {
	for _, o := range opts {
		o(s)
	}
	return s
}

// WithOptions configures the receiver SlicesAndMaps with the passed in options set
func (s *SlicesAndMaps) WithOptions(opts ...SlicesAndMapsOption) *SlicesAndMaps {
	for _, o := range opts {
		o(s)
	}
	return s
}

// WithTags returns an option that can append Tagss to SlicesAndMaps.Tags
func WithTags(tags string) SlicesAndMapsOption {
	return func(s *SlicesAndMaps) {
		s.Tags = append(s.Tags, tags)
	}
}

// SetTags returns an option that can set Tags on a SlicesAndMaps
func SetTags(tags []string) SlicesAndMapsOption {
	return func(s *SlicesAndMaps) {
		s.Tags = tags
	}
}

// WithMetadata returns an option that can append Metadatas to SlicesAndMaps.Metadata
func WithMetadata(key string, value interface{}) SlicesAndMapsOption {
	return func(s *SlicesAndMaps) {
		s.Metadata[key] = value
	}
}

// SetMetadata returns an option that can set Metadata on a SlicesAndMaps
func SetMetadata(metadata map[string]interface{}) SlicesAndMapsOption {
	return func(s *SlicesAndMaps) {
		s.Metadata = metadata
	}
}

// WithPorts returns an option that can append Portss to SlicesAndMaps.Ports
func WithPorts(ports int) SlicesAndMapsOption {
	return func(s *SlicesAndMaps) {
		s.Ports = append(s.Ports, ports)
	}
}

// SetPorts returns an option that can set Ports on a SlicesAndMaps
func SetPorts(ports []int) SlicesAndMapsOption {
	return func(s *SlicesAndMaps) {
		s.Ports = ports
	}
}

// flattenDebugMap recursively flattens nested maps using dot notation
func flattenDebugMap(debugMap map[string]any) map[string]any {
	flattened := make(map[string]any, len(debugMap))
	for key, value := range debugMap {
		childMap, ok := value.(map[string]any)
		if ok {
			for fk, fv := range flattenDebugMap(childMap) {
				flattened[key+"."+fk] = fv
			}
			continue
		}
		flattened[key] = value
	}
	return flattened
}
